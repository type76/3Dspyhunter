<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2D in 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <style>
    html, body {background: #222;}
    body {display: block; margin: 0 auto; padding: 0;  color: #fff; overflow: hidden; font-family: monospace;}
        canvas {width: 100%; height: 100%; display: block; position: absolute;}
        #cntrls {position: absolute; z-index: 2; padding: 0; margin: 8px;}
    </style>
</head>
<body>
<p id="cntrls">
controls: up|down|left|right <br>
accelerate:z <br>
brake:x</p>

    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.min.js"></script>

    <script>
var hero;
var revcounter = 0;
var topspeed = 10;
var slowdown = false;
var timerID;
var width = window.innerWidth,
height = window.innerHeight;
var camera, scene, renderer, geometry, texture, mesh, controls, keyboard;

THREE.SpriteSheetTexture = function(
    imageURL,
    framesX,
    frameDelay,
    _endFrame
) {
    var timer,
        frameWidth,
        frameHeight,
        x = (y = count = startFrame = 0),
        endFrame = _endFrame || framesX,
        canvas = document.createElement("canvas"),
        ctx = canvas.getContext("2d"),
        canvasTexture = new THREE.CanvasTexture(canvas),
        img = new Image();

    img.crossOrigin = "Anonymous";
    img.onload = function() {
        canvas.width = frameWidth = img.width / framesX;
        canvas.height = frameHeight = img.height;
        timer = setInterval(nextFrame, frameDelay);
    };
    img.src = imageURL;

    function nextFrame() {
        // count++;
        count += revcounter/100;
        // count += revcounter/frameDelay;

        if (count >= endFrame) {
            count = 0;
        }

        x = count*frameDelay;
        y = 0;

        ctx.clearRect(0, 0, frameWidth, frameHeight);
        ctx.drawImage(
            img,
            x,
            y,
            frameWidth,
            frameHeight,
            0,
            0,
            frameWidth,
            frameHeight
        );

        canvasTexture.needsUpdate = true;
    }

    return canvasTexture;
};


    function init() {
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 1000);
        camera.position.z = 0.1;
        camera.position.y = 20;
        scene.add(camera);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;

//  hero object
var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
hero = new THREE.Mesh( geometry, material );
scene.add( hero );


// ground
runtexture = new THREE.SpriteSheetTexture(
    "assets/17x.png",
    17,
    100,
    17
);
runtexture.magFilter = THREE.NearestFilter;
runtexture.minFilter = THREE.LinearMipMapLinearFilter;


// ground texture
var material = new THREE.MeshBasicMaterial( {
  color: 0xffffff 
  ,map:runtexture
  // , side:THREE.DoubleSide
 } );


var geometry = new THREE.PlaneBufferGeometry( 40, 40, 1 );
var groundplane = new THREE.Mesh( geometry, material );
groundplane.rotation.set (-Math.PI/2,0,Math.PI/2);
groundplane.position.set (0,-0.5,0);
scene.add( groundplane );


// keys
keyboard = {
    _pressed: {},

    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    Z: 90,
    X: 88,

    isDown: function(keyCode) {
        return this._pressed[keyCode];
    },

    onKeydown: function(event) {
        this._pressed[event.keyCode] = true;
    },

    onKeyup: function(event) {
        delete this._pressed[event.keyCode];
    }
};

// events
window.addEventListener( 'resize', onWindowResize, false );
window.addEventListener('keyup', function(event) { keyboard.onKeyup(event); }, false);
window.addEventListener('keydown', function(event) { keyboard.onKeydown(event); }, false);

}// init


// resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
}


// player movement update
function playerupdate() {
    if (keyboard.isDown(keyboard.LEFT))   {
        hero.position.x -= 1; 
    }
    if (keyboard.isDown(keyboard.RIGHT))   {
        hero.position.x += 1; 
    }
    if (keyboard.isDown(keyboard.UP))   {
        hero.position.z -= 1; 
    }
    if (keyboard.isDown(keyboard.DOWN))   {
        hero.position.z += 1; 
    }
    if (keyboard.isDown(keyboard.Z))   {
        accelerate();
        document.getElementById('cntrls').style.display = 'none';
    }
    if (keyboard.isDown(keyboard.X))   {
        decelerate();
    }
}// move player

// render loop
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    controls.update();
    playerupdate();
}


// START HERE >>>>>
window.addEventListener('load', initialise, false);

function initialise(){
init();
animate();
}



//

//go
function accelerate(e) {
  slowdown = false;
  stopwarp = false;
  timerID = cancelAnimationFrame(slowtimer);
  timerID = requestAnimationFrame(timer);
  if (e) {e.preventDefault();}
}
// brake
function decelerate(e) {
  slowdown = true;
  stopwarp = true; 
  timerID = cancelAnimationFrame(timerID);
  timerID = requestAnimationFrame(slowtimer);
  if (e) {e.preventDefault();}
}

// slow down
function slowtimer() {
        revcounter = revcounter-0.1;
        if (revcounter<0.1) {
          revcounter=0; 
          cancelAnimationFrame(slowtimer); 
          return;
        } else {
          requestAnimationFrame(slowtimer);
        }
      }


// speed up
function timer() { 
        if (revcounter < topspeed || slowdown == true) {
          timerID = requestAnimationFrame(timer);
        revcounter = revcounter+0.1;
      }
    }

</script>
</body>
</html>